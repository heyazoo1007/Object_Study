# Object_Study


책: 오브젝트(저자 조영호)
한 주에 책 5챕터씩 공부하고, 한 챕터씩 공부한 내용을 깃헙과 리드미에 기록하는 방식 

제대로 동작하는 것 뿐만 아니라 변경이 용이하고, 읽기 쉬운 코드를 작성하는 방법을 공부했다.

2022.05.08

객체지향 프로그래밍: 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식 

안 좋은 코드
객체들이 자유롭게 행동하지 않음
객체 하나에 너무 많은 책임이 있다. 의존성이 높다, 세부사항이 너무 많다
이는 곧 변경을 취약한 코드로 만든다.

따라서, 변경을 용이하게 만들려면 결합도를 줄이고, 응집도를 높인다
결합도를 줄이는 방법
응집도를 높이는 방법: 밀접하게 연관된 작업만을 수행하고, 연관성 없는 작업은 다른 객체에게 위임한다 

캡슐화: 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것 
캡슐화의 목적: 변경하기 쉬운 코드로 만드는 것 

2022.05.10

좋은 협력 -> 좋은 객체 -> 좋은 클래스
인터페이스: 객체가 이해할 수 있는 메시지 목록을 정의하는 것

훌륭한 클래스를 설계하기 위해선 '어떤 부분을 공개하고 어떤 부분을 감출지 결정하는 것' 
이를 위해선 접근제어 메커니즘을 이용한다

접근제어 메커니즘의 목적: 객체의 변경을 관리하기 위함 
1. 클래스의 내부와 외부 명확 -> 객체의 자율성 증가
2. 구현 은닉

구현 은닉을 하면 클라이언트 프로그래머는 내부 코드에 접근하지 못하므로 알아야될 정보가 적어지고,
클래스 작성자는 외부의 영향을 신경쓰지 않고 내부 구현할 수 있다

메시지 vs 메서드
메시지는 객체 간 상호작용을 하기 위한 유일한 방법이고,
메서드는 이 수신된 메시지를 처리하기 위한 자신만의 방법

Template Pattern
부모 클래스에 기본적인 알고리즘의 흐름을 구현하고, 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴

코드 의존성 != 실행 의존성인 상황

장점: 
유연하고, 재사용이 가능하므로 
확장가능한 객체지향을 설계할 수 있다.

단점: 객체 생성과 연결부분을 찾아야하므로 이해하기 어려울 수 있다. 

다형성: 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력 
다형성하는 방법들의 공통점: 
메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다 
-> 지연 바인딩(lazy binding) 또는 동적 바인딩(dynamic binding)

상속 vs 합성
상속
캠슐화 약해짐. 부모/자식 클래스간 결합이 강해지기 때문이다(자식의 메서드를 알기위해서는 부모클래스 내부를 알아야한다)
설계가 유연하지 않다. 실행 시점에 객체의 종류를 변경 불가능 

합성
합성을 하면 메시지를 통해 객체가 연결되므로 느슨한 결합을 가진다. 
구현을 효과적으로 캡슐화 한다. 인스턴스에 정해진 메시지로만 재사용이 가능하기 때문에
인스턴스 교체가 비교적 쉬워서 설계가 유연하다. 


2022.05.11
객체지향 프로그래밍에서 가장 중요한 것: 역할,책임,협력

협력: 에플리케이션의 기능을 구현하기 위해 수행하는 상호작용,객체지향 세계에서 기능을 구현할 수 있는 유일한 방법
상호작용: 다른 객체(해당 책임에 대한 정보 전문가)에게 메시지로 요청하는 것. 

메시지 전송: 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이다. 
수신한 객체는 메서드를 실행에 요청에 응답한다. 상태에 따라 메시지를 처리하는 방식이 다름. 이거는 객체가 직접 결정

객체: 상태와 행동을 함께 캡슐화 하는 실행 단위

협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공
협력이 객체의 행동을 결정하고, 행동이 객체의 상태를 결정한다
상태는 행동을 수행하는데 필요한 정보가 무엇인지로 결정된다

==================================================================
객체지향에서 가장 중요한 것은 책임이다. 
책임: 객체가 협력에 참여하기 위해 수행하는 행동,로직. 
객체에 의해 정의되는 응집도 있는 행위의 집합 
객체가 유지해야하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장
객체의 책임은 ‘무엇을 아는가’와 ‘무엇을 할 수 있는가’로 나뉜다 

책임 할당
정보전문가 패턴: 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 책임을 할당하는 것 
위의 패턴을 이용하면 좀 더 자율적인 객체를 만들 수 있다

협력(문맥) 정의 후 책임을 할당한다. 
책임 할당 == 메시지의 이름을 결정하는 것
책임 수행 == 메시지를 수신하는 것 

책임 주도 설계
협력을 설계하기 위해서는 책임에 초점을 맞춰야 한다. 어떤 책임을 선택하느냐가 전체적인 설계의 방향과 흐름을 결정한다
책임 주도 설계: 책임을 찾고, 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방식 

메시지가 객체를 선택하는 방법이 돼야하는 이유
1. 객체가 최소한의 인터페이스를 가질 수 있게 된다
메시지가 식별돼야 객체의 인터페이스에 행동목록이 추가되기 때문에 꼭 필요한 크기의 퍼블릭 인터페이스를 가질 수 있다. 

2. 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다 
객체의 인터페이스는 무엇을 하는지는 표현해야 하지만, 어떻게 수행하는지(행동 내부)를  노출하면 안된다. 
메시지는 외부의 객체가 요청하는 무언가를 의미하므로 메시지를 식별하는 무엇을 수행할지에 초점을 맞추는 인터페이스를 얻을 수 있다. 

협력에 얼마나 적절한지 판단 후 적절한 책임을 할당 후 적절한 객체를 생성한다
데이터 주도 설계(Data Driven Design): 객체 내부 구현에 초점을 맞춘 설계방법
DDD를 이용하면 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되기 때문에 캡슐화를 저해한다. 

*항상 협력이라는 문맥 안에서 객체를 생각해야한다 *
상태와 행동 중에서 훨씬 더 중요한 것은 행동!
행동 == 객체의 책임 

=======================================================================

역할: 객체가 특정 협력 안에서 수행하는 책임의 모임
하나의 역할 안에서 책임은 후보로 여러개의 객체를 가질 수 있다(DiscountPolicy에서 Amount와 Percent)

역할은 구체적인 객체를 포괄하는 추상화의 개념 
동일한 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합할 수 있다는 것. 
가장 큰 장점: 설계의 구성 요소를 추상화 할 수 있다.
—> 역할을 통해 유연하고, 확장가능한 설계구조를 가지는 시스템 구축 가능 

역할이 중요한 이유: 동일한 협력을 수행하는 객체들을 추상화할 수 있다. 
특정한 한 협력에서 객체는 하나의 역할을 가진다. 
이 객체는 다른 협력에서 다른 하나의 역할을 수행 할 수 있다.
하나의 객체는 여러 역할을 할 수 있지만 하나의 협력에서는 하나의 역할만 가진다. 
하나의 역할에 여러개의 객체들을 사용할 수 있다. 










