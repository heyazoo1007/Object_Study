### 목적

버그 걱정없이 코드를 변경할 수 있고, 변경에 유연하고 확장가능한  설계하는 방법

객체지향 프로그래밍: 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식

좋은 객체지향 설계: 올바른 객체에게 올바른 책임을 할당하면서 높은 응집도와 낮은 결합도를 가진 구조를 창조하는 활동

클래스 내부와 외부 구분 & 구현 은닉 

클래스의 내부와 외부가 명확하게 구분이 되면 객체의 자율성이 증가. 

구현 은닉을 하면 클라이언트 프로그래머 → 알아야될 정보 감소

클래스 작성자 → 외부 영향 신경쓰지 않고 내부 구현 가능

캡슐화:  외부에서 알 필요가 없는 부분은 감춤으로써 대상을 단순화하는 추상화의 한 종류(변경될 수 있는 어떤 것이라도 감추는 것)

캡슐화의 목적은 객체의 자율성 확보

객체가 자신의 데이터를 처리함에 있어서 자유로워야 변경이 쉬워진다

캡슐화를 먼저 확보해야 낮은 결합도와 높은 응집도를 만들 수 있다

메시지 vs 메서드

메시지: 객체 간 상호작용을 하기 위한 유일한 방법.

메서드: 수신된 메시지를 처리하기 위한 자신만의 방법. 이는 객체가 직접 결정한다. 

다형성: 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력

장점: 타입 객체에 변경사항이 생기거나 새로운 타입을 추가해야할 때, 큰 어려움없이 변경할 수 있다. 예제 DiscountPolicy에 연결된 AmountDiscountPolicy와 PercentDiscountPolicy

상속 vs 합성

상속: 내부 구현을 그대로 사용해야하는 경우. 

부모와 자식 클래스 간의 결합이 강해져 캡슐화가 약해진다

합성: 메시지를 통해 객체가 연결되므로 느슨한 결합을 가져서 효과적으로 캡슐화 가능. 느슨한 결합으로 낮은 결합도를 가진다. 

---

## 협력,책임,역할

객체: 상태와 행동을 함께 캡슐화하는 실행 단위 

### 협력

- 애플리케이션의 기능을 구현하기 위해 메시지를 주고받는 객체들 사이의 상호작용을 의미한다.
- 협력은 객체가 필요한 이유를 제공한다.

**협력**→ 객체의 **행동**을 결정 → 객체의 **상태**(행동을 수행하는데 필요한 정보가 무엇인지를 나타냄)를 결정 

### *책임*

- 객체가 다른 객체와 협력하기 위해 수행하는 행동,로직
- 객체가 유지해야하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장
- 객체지향에서 가장 중요함!
- 어떤 책임을 선택하느냐가 전체적인 설계의 방향과 흐름을 결정

> 책임 주도 설계
> 

책임을 찾고, 책침을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방식  

이후 책임 주도 설계와 책임 할당에 관해 GRASP 패턴에서 자세하게 설명할 예정

### 역할

- 대체가능한 책임의 집합
- 구체적인 객체를 포괄하는 추상화의 개념
- 동일한 책임을 수행하는 역할을 기반으로 두개의 협력을 하나로 통합할 수 있다

- 역할의 장점: 설계의 구성요소를 추상화 할 수 있다.

→ 하나의 역할에 여러개의 객체들을 사용할 수 있어 유연하고, 확장가능한 설계구조를 가지는 시스템 구축 가능

---

## 캡슐화, 응집도, 결합도

객체지향 설계 핵심 : 책임과 책임을 할당하는 작업.

객체의 행동,책임에 집중하면 응집도가 높고 느슨한 결합을 만들 수 있고, 이는 효과적으로 변경가능하다. 

> 구현 vs 인터페이스
> 

구현: 변경될 가능성이 높은 부분

인터페이스: 외부에 노출되고, 상대적으로 안정적인 부분 

### 캡슐화

캡슐화:  외부에서 알 필요가 없는 부분은 감춤으로써 대상을 단순화하는 추상화의 한 종류(변경될 수 있는 어떤 것이라도 감추는 것)

캡슐화가 중요한 이유: 구현(불안정한 부분)과 인터페이스(안정적인 부분)를 분리해서 변경의 영향을 통제할 수 있기 때문이다 

캡슐화를 기본으로 만족해야 이후에 높은 응집도와 낮은 결합도를 설계할 수 있다

### 응집도

모듈에 포함된 내부요소들이 연관돼 있는 정도를 나타낸다

하나의 클래스에 관련없는 요소들이 많으면 응집도가 낮다고 한다

높은 응집도를 가지면 

- 변경의 대상과 범위가 명확해진다 → 1 요구사항, 1 변경
- 객체 또는 클래스에 관련 높은 책임들을 할당했는지 알 수 있다.

낮은 응집도 

- 변경사항과 관련이 없는 코드가 수정될 수 있고, 하나의 요구사항 변경에 여러개의 모듈을 변경할 수 있다.

### 결합도

객체 간 의존성 정도를 나타내며, 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지 나타냄

낮은 결합도를 가지면  

- 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지할 수 있다
- 변경의 대상 수가 줄어든다

협력 앎 → 책임에 초점 → 캡슐화 가능

협력 모름 → 접근자/생성자 → 내부구현이 인터페이스에 노출 → 캡슐화 위반

예시: DDD

---

## 책임주도 설계 하는 법

- 데이터보다 행동을 먼저 결정하라

### 협력이라는 문맥 안에서 책임을 결정하라

메시지 전송자(클라이언트)의 의도에 적합한 책임을 할당하는 것

메시지== 클라이언트의 의도

메시지를 먼저 결정하고, 그에 적합한 객체를 선택하는 순서

### GRSAP 패턴

: 객체에게 책임을 할당할 때 원칙들의 집합을 패턴 형식으로 정리한 것

### 1. Information Expert Pattern

책임을 수행할 정보를 알고있는 객체에게 책입을 할당하는 것

하지만, 정보전문가가 데이터를 반드시 저장하고 있을 필요는 없다

(정보를 다 알고 있지 않아도, 어떤 객체와 협력을 해야하는지 알고만 있어도 된다는 뜻?)

### 2. Creator Pattern

객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다

B가 A에 대해 다음 조건을 만족할 때, 객체생성 책임을 할당할 수 있다

- B가 A객체를 잘 알고 있거나
- 긴밀하게 사용하거나
- 초기화에 필요한 데이터를 가지고 있는 경우

다형성 패턴전에 낮은 응집도를 구별하는 방법을 알아야한다

응집도가 낮다: 서로 연관성이 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐져 있다는 의미

이를 해결하기 위해서는 변경의 이유에 따라 클래스를 분리해야 한다.

코드를 통해 변경의 이유를 파악하는 방법

1. 인스턴스 변수가 초기화되는 시점 확인

해결방법: 함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.

1. 메서드들이 인스턴스 변수를 사용하는 방식 확인

해결방법: 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.

### 3. Polymorphism Pattern

객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하는 것.

겹치는 행동들이 있다면 상위개념으로 타입을 지정하고, 책임에 따라 다르게 행동하는 하위개념이 있는 형태?

### 4. Protected Variations Pattern

: 변경을 캡슐화하도록 책임을 할당하는 것
